import { Injectable } from "@nestjs/common";

@Injectable()
export class Utils {

  /**
   * Converts a given string to a "slug" format suitable for URLs. The conversion involves
   * lowercasing the entire string, replacing spaces with hyphens, and removing all non-alphanumeric
   * characters except hyphens. This function is useful for creating clean and SEO-friendly URLs
   * from titles or names.
   *
   * @public
   * @function convertToSlug
   * @param {string} string - The string to be converted into a slug.
   * @returns {string} The slugified version of the input string, which is lowercased, with spaces
   *                   replaced by hyphens, and stripped of all non-word characters.
   */
  public convertToSlug = (string: string): string => string.toLowerCase().replace(/ /g, '-').replace(/[^\w-]+/g, '')

  /**
   * Validates whether a given string conforms to a pattern suitable for URL slugs. The pattern ensures that the slug
   * consists only of lowercase letters, numbers, and hyphens. This is useful for ensuring that generated or inputted
   * slugs are compatible with URL standards and do not contain any invalid characters.
   *
   * @public
   * @function isValidSlug
   * @param {string} slug - The string to be validated as a slug.
   * @returns {boolean} Returns true if the string is a valid slug according to the pattern, otherwise returns false.
   */
  public isValidSlug = (slug: string) => {
    const slugPattern = /^[a-z0-9-]+$/;
    return slugPattern.test(slug);
  }

  /**
   * Creates a timer that completes after a specified number of milliseconds. This function is useful
   * for delaying operations within async functions, akin to using `setTimeout` in asynchronous
   * workflows. The returned Promise resolves after the specified delay, allowing the use of `await`
   * for pausing execution in an async function.
   *
   * @public
   * @function timer
   * @param {number} ms - The number of milliseconds to delay.
   * @returns {Promise<void>} A promise that resolves after the delay, effectively pausing execution
   *                          for the specified period.
   */
  public timer = (ms: number): Promise<unknown> => new Promise(res => setTimeout(res, ms))

  /**
   * Retrieves a shorthand permission code based on the user's role name. This utility function is used internally
   * to simplify and standardize the representation of user permissions across the application. Each role is mapped
   * to a specific shorthand that is returned when the role name matches a case in the switch statement.
   *
   * @private
   * @function getUserPermissions
   * @param {string} roleName - The name of the user role.
   * @returns {string} The shorthand code for the given user role. Returns an empty string if no matching role is found.
   */
  public getUserPermissions = (roleName: string): string => {
    switch (roleName) {
      case 'root': return 'Rt';
      case 'admin': return 'Adm';
      case 'client': return 'Clt';
      default: return '';
    }
  }

  /**
   * Capitalizes the first letter of a given string and returns the string with the initial letter capitalized
   * while keeping the rest of the string as is. This function is useful for ensuring that user input such as
   * names and titles are standardized in terms of capitalization, which can be important for UI display or data
   * consistency.
   *
   * @public
   * @function capitalizeFirstLetter
   * @param {string} str - The string to capitalize.
   * @returns {string} The modified string with the first letter capitalized.
   */
  public capitalizeFirstLetter = (str: string): string => {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  /**
   * Validates an email address against a regular expression to ensure it conforms to a standard email format.
   * The function uses a comprehensive regex pattern that covers a wide range of valid email characters, including
   * normal alphanumeric characters, special characters within the username part, and a valid domain format.
   *
   * @param {string} email - The email address to validate.
   * @returns {boolean} Returns true if the email matches the regex pattern, indicating it is a valid email address.
   *                    Returns false otherwise.
   */
  public validateEmail = (email: string): boolean => {
    const regex = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    return regex.test(email);
  }

  /**
   * Generates a random password with the specified length. The password is generated by combination
   * of lowercase, uppercase, and numeric characters. The function ensure at least one character from each category,
   * fill remaining characters with any character from the combined set and shuffle the password for randomness.
   *
   * @public
   * @function generatePassword
   * @param {number} length - The length of the password to generate. Defaults to 8.
   * @returns {string} The generated password with the specified length.
   */
  public generatePassword = (length: number = 8): string => {
    const lowercaseChars = "abcdefghijklmnopqrstuvwxyz";
    const uppercaseChars = lowercaseChars.toUpperCase();
    const numberChars = "0123456789";
    const allChars = lowercaseChars + uppercaseChars + numberChars;

    let password = "";

    password += lowercaseChars[Math.floor(Math.random() * lowercaseChars.length)];
    password += uppercaseChars[Math.floor(Math.random() * uppercaseChars.length)];
    password += numberChars[Math.floor(Math.random() * numberChars.length)];

    for (let i = password.length; i < length; i++) {
      password += allChars[Math.floor(Math.random() * allChars.length)];
    }
  }

  return password.split("").sort(() => Math.random() - 0.5).join("");
}

export { HandleErrors } from './handleErrors.util';
